PROBLEM STATEMENT:
Given the root of a binary tree, the depth of each node is the shortest distance to the root.

Return the smallest subtree such that it contains all the deepest nodes in the original tree.

A node is called the deepest if it has the largest depth possible among any node in the entire tree.

The subtree of a node is a tree consisting of that node, plus the set of all descendants of that node.

SOLUTION:

                                                                                                      TIME COMPLEXITY: O(N)
                                                                                                      SPACE COMPLEXITY: O(N)

class Solution {
    HashMap<TreeNode, Integer> mp;
    int maxDepth;
    public TreeNode subtreeWithAllDeepest(TreeNode root) {
        mp= new HashMap<>();
        mp.put(null, -1);
        maxDepth=-1;
        dfs(root,null);
        maxDepth=-1;
        for(Integer d: mp.values()){
            maxDepth= Math.max(maxDepth, d);
        }

        return f(root);
    }
    public void dfs(TreeNode node, TreeNode parent){
        if(node!=null){
            mp.put(node, mp.get(parent)+1);
            dfs(node.left, node);
            dfs(node.right, node);
        }
    }
    public TreeNode f(TreeNode node){
        if(node==null || mp.get(node)==maxDepth)    return node;

        TreeNode l= f(node.left);
        TreeNode r= f(node.right);
        if(l!= null && r!=null) return node;
        if(l!=null) return l;
        if(r!=null) return r;
        return null;
    }
}
