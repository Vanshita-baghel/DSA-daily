PROBLEM STATEMENT:
You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English letters. You are also given two 0-indexed character arrays original and changed, and an integer array cost, where cost[i] represents the cost of changing the character original[i] to the character changed[i].

You start with the string source. In one operation, you can pick a character x from the string and change it to the character y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y.

Return the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.

Note that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].

SOLUTION:

                                                                                            TIME COMPLEXITY: O(n)
                                                                                            SPACE COMPLEXITY: O(1)

class Solution {
    public long minimumCost(String source, String target, char[] original, char[] changed, int[] cost) {       
        int n= source.length();
        int m=target.length();

        if(m!=n)    return -1; 

        //prepare a all pair shortest path 
        int[][] dist= new int[26][26];
        for(int i=0; i<26; i++){
            Arrays.fill(dist[i], Integer.MAX_VALUE);
            dist[i][i]=0;
        }

        for(int i=0; i<original.length; i++){
            int u=original[i]-'a', v=changed[i]-'a';
            dist[u][v]= Math.min(dist[u][v], cost[i]);
        }

        floydWarshall(original, changed, cost, dist);

        long ans=0;

        for(int i=0; i<n; i++){
            char ch1=source.charAt(i), ch2= target.charAt(i);
            if(ch1==ch2)    continue;
            else{
                int minCost=dist[ch1-'a'][ch2-'a'];
                if(minCost==Integer.MAX_VALUE)  return -1;
                ans= ans+minCost;
            }
        }
        return ans;
    }
    public void floydWarshall(char[] original,char[] changed,int[] cost, int[][] dist){
         
        for(int k=0; k<26; k++){
            for(int i=0; i<26; i++){
                for(int j=0; j<26; j++){
                    if(dist[i][k]!=Integer.MAX_VALUE && dist[k][j]!=Integer.MAX_VALUE){
                        dist[i][j]= Math.min(dist[i][j], dist[i][k]+dist[k][j]);
                    }
                }
            }
        }
    }
}
