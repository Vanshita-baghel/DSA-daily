PROBLEM STATEMENT:
You are given a 0-indexed array nums consisiting of positive integers. You can do the following operation on the array any number of times:

Select an index i such that 0 <= i < n - 1 and replace either of nums[i] or nums[i+1] with their gcd value.
Return the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1.

The gcd of two integers is the greatest common divisor of the two integers.


SOLUTION:

                                                                                      TIME COMPLEXITY: O(n^2)
                                                                                      SPACE COMPLEXITY: O(1)

class Solution {

    public int minOperations(int[] nums) {
        int n= nums.length;
        int ones=0;
        for(int num: nums){
            if(num==1)  ones++;
        }

        if(ones==n)   return 0;
        if(ones>0)   return n-ones;

        int len= minSubarrayWithGcd1(nums);
        if(len==-1)  return -1;
        return (len-1)+(n-1);
    }
    public int minSubarrayWithGcd1(int[] nums){
        int minLen= Integer.MAX_VALUE, n= nums.length;
        for(int i=0; i<n; i++){
            int g= nums[i];
            for(int j=i; j<n; j++){
                g= gcd(g, nums[j]);
                if(g==1){
                    minLen= Math.min(minLen, j-i+1);
                    break;
                }
            }
        }
        return minLen==Integer.MAX_VALUE? -1: minLen;
    }

    public int gcd(int a, int b){
        while(b!=0){
            int temp= b;
            b= a%b;
            a= temp;
        }
        return a;
    }
}
