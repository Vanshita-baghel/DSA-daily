PROBLEM STATEMENT:
You are given an integer array nums of length n.

A trionic subarray is a contiguous subarray nums[l...r] (with 0 <= l < r < n) for which there exist indices l < p < q < r such that:

nums[l...p] is strictly increasing,
nums[p...q] is strictly decreasing,
nums[q...r] is strictly increasing.
Return the maximum sum of any trionic subarray in nums.

SOLUTION:

                                                                              TIME COMPLEXITY: O(n)
                                                                              SPACE COMPLEXITY: O(n)

class Solution {
    int n;
    static final long NEG= Long.MIN_VALUE/2;
    public long maxSumTrionic(int[] nums) {
        n=nums.length;

        long[][] dp= new long[n][4];
        for(int i=0; i<n; i++){
            Arrays.fill(dp[i], Long.MIN_VALUE);
        }

        return solve(0,0, nums, dp);
    }
    public long solve(int i, int trend, int[] nums, long[][] dp){
        //base case

        if(i==n){
            if(trend==3)    return 0;
            else    return NEG;
        }

        if(dp[i][trend] != Long.MIN_VALUE)  return dp[i][trend];

        long take= NEG;
        long skip= NEG;

        if(trend==0){
            skip= solve(i+1, 0, nums, dp);
        }
        if(trend==3){
            take= nums[i];
        }
        if(i+1 <n){
            int cur= nums[i];
            int next= nums[i+1];

            if(trend==0 && cur<next){
                //first increasing
                take= Math.max(take, cur+solve(i+1, 1, nums, dp));
            }
            else if(trend==1){
                if(cur<next){
                    take= Math.max(take, cur+solve(i+1, 1, nums, dp));
                }
                else if(cur>next){
                    take= Math.max(take, cur+solve(i+1, 2, nums, dp));
                }
            }
            else if(trend==2){      //decreasing
                if(cur>next){
                    take= Math.max(take, cur+solve(i+1, 2, nums, dp));
                }
                else if(cur<next){
                    take= Math.max(take, cur+solve(i+1,3, nums, dp));
                }
            }
            else if(trend==3 && cur<next){
                take= Math.max(take, cur+solve(i+1,3, nums, dp));
            }
        }

        return dp[i][trend]= Math.max(take, skip);
    }
}
